#![cfg(all(feature = "control-flow", feature = "disasm-capstone"))]

use threatflux_binary_analysis::analysis::control_flow;
use threatflux_binary_analysis::types::ControlFlow as FlowType;
use threatflux_binary_analysis::BinaryFile;

fn create_test_elf() -> Vec<u8> {
    let mut data = vec![0u8; 2048];

    let elf_header = [
        0x7f, 0x45, 0x4c, 0x46, // EI_MAG
        0x02, // 64-bit
        0x01, // little endian
        0x01, // version
        0x00, // osabi
        0x00, // abiversion
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
        0x02, 0x00, // ET_EXEC
        0x3e, 0x00, // x86_64
        0x01, 0x00, 0x00, 0x00, // version
        0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // entry
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // phoff
        0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // shoff
        0x00, 0x00, 0x00, 0x00, // flags
        0x40, 0x00, // ehsize
        0x38, 0x00, // phentsize
        0x02, 0x00, // phnum
        0x40, 0x00, // shentsize
        0x04, 0x00, // shnum
        0x03, 0x00, // shstrndx
    ];
    data[..64].copy_from_slice(&elf_header);

    let ph_load = [
        0x01, 0x00, 0x00, 0x00, // PT_LOAD
        0x05, 0x00, 0x00, 0x00, // flags R|X
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // offset
        0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // vaddr
        0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // paddr
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // filesz
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // memsz
        0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // align
    ];
    let ph_gnu_stack = [0u8; 56];
    data[64..120].copy_from_slice(&ph_load);
    data[120..176].copy_from_slice(&ph_gnu_stack);

    let sh_null = [0u8; 64];
    let sh_text = [
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];
    let sh_shstrtab = [0u8; 64];
    data[1024..1088].copy_from_slice(&sh_null);
    data[1088..1152].copy_from_slice(&sh_text);
    data[1152..1216].copy_from_slice(&sh_shstrtab);

    let shstrtab = b"\0.text\0shstrtab\0";
    data[768..768 + shstrtab.len()].copy_from_slice(shstrtab);

    let instructions = [
        0x48, 0x89, 0xe5, 0x48, 0x83, 0xec, 0x10, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0x83, 0xc4,
        0x10, 0x5d, 0xc3,
    ];
    data[512..512 + instructions.len()].copy_from_slice(&instructions);

    data
}

#[test]
fn test_control_flow_analysis_from_binary() {
    let data = create_test_elf();
    let binary = BinaryFile::parse(&data).expect("parse ELF");
    let cfgs = control_flow::analyze_binary(&binary).expect("analyze");
    assert!(!cfgs.is_empty());
    let cfg = &cfgs[0];
    assert!(!cfg.basic_blocks.is_empty());
    let has_return = cfg.basic_blocks.iter().any(|b| {
        b.instructions
            .iter()
            .any(|i| matches!(i.flow, FlowType::Return))
    });
    assert!(has_return);
}
